from __future__ import annotations
from typing import Any, List, Optional

from .protocols import OneToOne, OneToMany
from .wrappers import (
    FnWrapper,
    PopIdFields,
    RenameOutput,
    RenameInput,
    AddToInput,
    AddToOutput,
    into_one,
    into_many,
)


class FnBuilderBase:
    id_fields: Optional[list[str]]
    """
    Keeps track of the tasks that were popped using `FnBuilderBase.pop_id_fields`

    Tasks may use this information to guess which fields uniquely identify a row
    """

    def __init__(self) -> None:
        """Base class for function wrapper builders"""
        self._wrappers: List[FnWrapper] = []
        self.id_fields = None

    def add_wrapper(self, wrapper: FnWrapper):
        """Apply a custom wrapper"""

        self._wrappers.append(wrapper)
        return self

    def pop_id_fields(self, *id_fields: str, keep: bool = False):
        """(Optionally) removes fields from the input kwargs
        and reinserts them back into the output

        Additionally, `*id_fields` are appended to `self.id_fields` list for use in SQL generation

        ---

        Args:
        - `*id_fields` (str): fields to pop from the kwargs
        - keep (bool, optional): if True, `id_fields` are not removed from kwargs
        (but still remembered and reinserted into the output), False by default"""
        self.add_wrapper(PopIdFields(*id_fields, keep=keep))

        # Remember the names of the popped fields (useful for SQL generation)
        if not self.id_fields:
            self.id_fields = []

        for id_field in id_fields:
            self.id_fields.append(id_field)

        return self

    def rename_input(self, remap_fields: dict[str, str]):
        """Remaps field names in the `**kwargs` dictionary"""
        self.add_wrapper(RenameInput(remap_fields))
        return self

    def rename_output(self, remap_fields: dict[str, str]):
        """Remaps field values in dictionaries generated by the inner function"""
        self.add_wrapper(RenameOutput(remap_fields))
        return self

    def add_to_input(self, add_values: dict[str, Any]):
        """Add extra key-value pairs to input"""
        self.add_wrapper(AddToInput(add_values))
        return self

    def add_to_output(self, add_values: dict[str, Any]):
        """Add extra key-value pairs to output"""
        self.add_wrapper(AddToOutput(add_values))
        return self

    def _wrap_all(self, fn: OneToMany) -> OneToMany:
        """Apply all of the wrappers in the order they were added"""
        for wrapper in self._wrappers:
            fn = wrapper.wrap(fn)
        return fn


class GeneratorBuilder(FnBuilderBase):
    def __init__(self, fn: OneToMany) -> None:
        """
        Build a function of type `(*args) -> Generator[dict]`

        Args:
        - fn (OneToMany): Base function to build wrappers around
        """
        super().__init__()
        self._fn = fn

    @staticmethod
    def from_fn(fn: OneToOne) -> GeneratorBuilder:
        """
        Create from a function of type `(*args) -> dict`
        by converting it into a generator function
        """

        return GeneratorBuilder(into_many(fn))

    def build(self) -> OneToMany:
        """Returns the wrapped function"""
        return self._wrap_all(self._fn)


class FnBuilder(FnBuilderBase):
    def __init__(self, fn: OneToOne) -> None:
        """
        Build a function of type `(*args) -> dict`

        Args:
        - fn (OneToOne): Base function to build wrappers around
        """
        super().__init__()
        self.fn = fn

    @staticmethod
    def from_generator(fn: OneToMany) -> FnBuilder:
        """
        Create from a function of type `(*args) -> Generator[dict]`
        that yields a single value
        """
        return FnBuilder(into_one(fn))

    def build(self) -> OneToOne:
        """Returns the wrapped function"""
        return into_one(self._wrap_all(into_many(self.fn)))
