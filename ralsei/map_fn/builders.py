from __future__ import annotations
from typing import Any, List, Optional

from .protocols import OneToOne, OneToMany
from .wrappers import (
    FnWrapper,
    PopIdFields,
    RenameOutput,
    RenameInput,
    AddToInput,
    AddToOutput,
    into_one,
    into_many,
)


class FnBuilderBase:
    """Base class for function wrapper builders"""

    def __init__(self) -> None:
        self.wrappers: List[FnWrapper] = []
        self.id_fields: Optional[list[str]] = None

    def add_wrapper(self, wrapper: FnWrapper):
        self.wrappers.append(wrapper)
        return self

    def pop_id_fields(self, *id_fields: str, keep: bool = False):
        """(Optionally) removes fields from the input kwargs
        and reinserts them back into the output

        Additionally, `*id_fields` are appended to `self.id_fields` list for use in SQL generation
        ---
        Args:
        - `*id_fields` (str): fields to pop from the kwargs
        - keep (bool, optional): if True, `id_fields` are not removed from kwargs
        (but still remembered and reinserted into the output), False by default"""
        self.add_wrapper(PopIdFields(*id_fields, keep=keep))

        # Remember the names of the popped fields (useful for SQL generation)
        if not self.id_fields:
            self.id_fields = []

        for id_field in id_fields:
            self.id_fields.append(id_field)

        return self

    def rename_input(self, remap_fields: dict[str, str]):
        """Remaps field names in the `**kwargs` dictionary"""
        self.add_wrapper(RenameInput(remap_fields))
        return self

    def rename_output(self, remap_fields: dict[str, str]):
        """Remaps field values in dictionaries generated by the inner function"""
        self.add_wrapper(RenameOutput(remap_fields))
        return self

    def add_to_input(self, add_values: dict[str, Any]):
        """Add extra key-value pairs to input"""
        self.add_wrapper(AddToInput(add_values))
        return self

    def add_to_output(self, add_values: dict[str, Any]):
        """Add extra key-value pairs to output"""
        self.add_wrapper(AddToOutput(add_values))
        return self

    def _wrap_all(self, fn: OneToMany) -> OneToMany:
        """Apply all of the wrappers in the order they were added"""
        for wrapper in self.wrappers:
            fn = wrapper.wrap(fn)
        return fn


class GeneratorBuilder(FnBuilderBase):
    """Build a function of type `(*args) -> Generator[dict]`"""

    def __init__(self, fn: OneToMany) -> None:
        """Args:
        - fn (OneToMany): Base function around which to create wrappers"""
        super().__init__()
        self.fn = fn

    @staticmethod
    def from_fn(fn: OneToOne) -> GeneratorBuilder:
        return GeneratorBuilder(into_many(fn))

    def build(self) -> OneToMany:
        return self._wrap_all(self.fn)


class FnBuilder(FnBuilderBase):
    """Build a function of type (*args) -> dict"""

    def __init__(self, fn: OneToOne) -> None:
        """Args:
        - fn (OneToOne): Base function around which to create wrappers"""
        super().__init__()
        self.fn = fn

    @staticmethod
    def from_generator(fn: OneToMany) -> FnBuilder:
        return FnBuilder(into_one(fn))

    def build(self) -> OneToOne:
        return into_one(self._wrap_all(into_many(self.fn)))
