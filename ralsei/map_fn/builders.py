from __future__ import annotations
from typing import Any, List, Optional

from .protocols import OneToOne, OneToMany
from .wrappers import (
    FnWrapper,
    PopIdFields,
    RenameOutput,
    RenameInput,
    AddToInput,
    AddToOutput,
    into_one,
    into_many,
)


class FnBuilderBase:
    id_fields: Optional[list[str]]
    """
    Keeps track of the tasks that were popped using `FnBuilderBase.pop_id_fields`

    Tasks may use this information to guess which fields uniquely identify a row
    """

    def __init__(self) -> None:
        """Base class for function wrapper builders"""
        self._wrappers: List[FnWrapper] = []
        self.id_fields = None

    def add_wrapper(self, wrapper: FnWrapper):
        """
        Apply a custom wrapper

        Args:
            wrapper: custom wrapper class
        """

        self._wrappers.append(wrapper)
        return self

    def pop_id_fields(self, *id_fields: str, keep: bool = False):
        """
        (Optionally) removes fields from the input kwargs
        and reinserts them back into the output

        Additionally, `*id_fields` are appended to `self.id_fields` list for use in SQL generation

        Args:
            *id_fields: fields to pop from the kwargs
            keep: if True, `id_fields` are not removed from kwargs
                (but still remembered and reinserted into the output)
        """
        self.add_wrapper(PopIdFields(*id_fields, keep=keep))

        # Remember the names of the popped fields (useful for SQL generation)
        if not self.id_fields:
            self.id_fields = []

        for id_field in id_fields:
            self.id_fields.append(id_field)

        return self

    def rename_input(self, remap_fields: dict[str, str]):
        """
        Remaps field names in the `**kwargs` dictionary

        Args:
            remap_fields: old_name -> new_name remap
        """
        self.add_wrapper(RenameInput(remap_fields))
        return self

    def rename_output(self, remap_fields: dict[str, str]):
        """
        Remaps field values in dictionaries generated by the inner function

        Args:
            remap_fields: old_name -> new_name remap
        """
        self.add_wrapper(RenameOutput(remap_fields))
        return self

    def add_to_input(self, add_values: dict[str, Any]):
        """
        Add extra key-value pairs to input

        Args:
            add_values: field names and values
        """
        self.add_wrapper(AddToInput(add_values))
        return self

    def add_to_output(self, add_values: dict[str, Any]):
        """
        Add extra key-value pairs to output

        Args:
            add_values: field names and values
        """
        self.add_wrapper(AddToOutput(add_values))
        return self

    def _wrap_all(self, fn: OneToMany) -> OneToMany:
        """Apply all of the wrappers in the order they were added"""
        for wrapper in self._wrappers:
            fn = wrapper.wrap(fn)
        return fn


class GeneratorBuilder(FnBuilderBase):
    def __init__(self, fn: OneToMany) -> None:
        """
        Build a function that maps one row to many rows

        Args:
            fn: base function to build wrappers around
        """
        super().__init__()
        self._fn = fn

    @staticmethod
    def from_fn(fn: OneToOne) -> GeneratorBuilder:
        """
        Create from a one-to-one function
        by converting it into a generator function

        Args:
            fn: base function to build wrappers around

        Returns:
            self
        """

        return GeneratorBuilder(into_many(fn))

    def build(self) -> OneToMany:
        """
        Apply all wrappers

        Returns:
            the wrapped function
        """
        return self._wrap_all(self._fn)


class FnBuilder(FnBuilderBase):
    def __init__(self, fn: OneToOne) -> None:
        """
        Build a one-to-one mapping function

        Args:
            fn: base function to build wrappers around
        """
        super().__init__()
        self.fn = fn

    @staticmethod
    def from_generator(fn: OneToMany) -> FnBuilder:
        """
        Create from a generator function
        that yields a single value

        Args:
            fn: base function to build wrappers around

        Returns:
            self

        Raises:
            ValueError: If there's more than one value in the generator
        """
        return FnBuilder(into_one(fn))

    def build(self) -> OneToOne:
        """
        Apply all wrappers

        Returns:
            the wrapped function
        """
        return into_one(self._wrap_all(into_many(self.fn)))


__all__ = ["FnBuilder", "GeneratorBuilder"]
