from abc import ABC, abstractmethod
from typing import Any

from .protocols import OneToOne, OneToMany


class FnWrapper(ABC):
    @abstractmethod
    def wrap(self, fn: OneToMany) -> OneToMany:
        """
        Apply a wrapper to fn

        Args:
            fn: inner function

        Returns:
            wrapped function
        """
        pass


class PopIdFields(FnWrapper):
    def __init__(self, *id_fields: str, keep: bool = False) -> None:
        """
        (Optionally) removes fields from the input kwargs
        and reinserts them back into the output

        Args:
            *id_fields: fields to pop from the kwargs
            keep: if True, `id_fields` are not removed from kwargs
                (but still remembered and reinserted into the output)
        """
        self._id_fields = id_fields
        self._keep = keep

    def wrap(self, fn: OneToMany) -> OneToMany:
        def wrapper(**input_row: Any):
            id_field_values = {}

            # Pop (or copy) id fields from input_row and save them in id_field_values
            for id_field in self._id_fields:
                id_field_values[id_field] = (
                    input_row[id_field] if self._keep else input_row.pop(id_field)
                )

            # Reinsert id_field_values into output
            for output_row in fn(**input_row):
                yield {**id_field_values, **output_row}

        return wrapper


class RenameInput(FnWrapper):
    def __init__(self, remap_fields: dict[str, str]) -> None:
        """
        Remaps field names in the `**kwargs` dictionary

        Args:
            remap_fields: old_name -> new_name remap
        """

        self._remap_fields = remap_fields

    def wrap(self, fn: OneToMany) -> OneToMany:
        def wrapper(**input_row: Any):
            new_input_row = {}

            for old_name, value in input_row.items():
                new_name = self._remap_fields.get(old_name, old_name)
                new_input_row[new_name] = value

            yield from fn(**new_input_row)

        return wrapper


class RenameOutput(FnWrapper):
    def __init__(self, remap_fields: dict[str, str]) -> None:
        """
        Remaps field values in dictionaries generated by the inner function

        Args:
            remap_fields: old_name -> new_name remap
        """

        self._remap_fields = remap_fields

    def wrap(self, fn: OneToMany) -> OneToMany:
        def wrapper(**input_row: Any):
            for output_row in fn(**input_row):
                new_output_row = {}

                for old_name, value in output_row.items():
                    new_name = self._remap_fields.get(old_name, old_name)
                    new_output_row[new_name] = value

                yield new_output_row

        return wrapper


class AddToInput(FnWrapper):
    def __init__(self, add_values: dict[str, Any]) -> None:
        """
        Add extra key-value pairs to input

        Args:
            add_values: field names and values
        """

        self._add_values = add_values

    def wrap(self, fn: OneToMany) -> OneToMany:
        def wrapper(**input_row: Any):
            yield from fn(**input_row, **self._add_values)

        return wrapper


class AddToOutput(FnWrapper):
    def __init__(self, add_values: dict[str, Any]) -> None:
        """
        Add extra key-value pairs to output

        Args:
            add_values: field names and values
        """

        self._add_values = add_values

    def wrap(self, fn: OneToMany) -> OneToMany:
        def wrapper(**input_row: Any):
            for output_row in fn(**input_row):
                yield {**output_row, **self._add_values}

        return wrapper


def into_many(fn: OneToOne) -> OneToMany:
    """
    Convert a regular function
    into a generator function yielding a single value

    Args:
        fn: inner function

    Returns:
        wrapped function
    """

    def wrapper(**input_row: Any):
        yield fn(**input_row)

    return wrapper


def into_one(fn: OneToMany) -> OneToOne:
    """
    Convert a function that returns a generator yielding a single value
    into a function that returns that value

    Args:
        fn: inner function

    Returns:
        wrapped function

    Raises:
        ValueError: If there's more than one value in the generator
    """

    def wrapper(**input_row: Any):
        generator = fn(**input_row)
        first_value = next(generator)

        # If there's more than one value in the generator, throw an error
        try:
            next(generator)
        except StopIteration:
            return first_value

        raise ValueError("Passed generator that returns more than one value")

    return wrapper
