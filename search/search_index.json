{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Ralsei is a Python framework for building modular data pipelines running inside the postgres database.</p> <p>It was built with use cases such as web scraping in mind, with the philosophy that all artifacts should be stored in the database: from downloaded html to the parsed results</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Based on the jinja-psycopg     library, combining type-safe SQL formatting with jinja's template language</li> <li>Declarative with minimal boilerplate</li> <li>Resumable pipelines, both at row-level and table-level granularity -     no need to re-compute or re-download what has already been processed</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install ralsei\n</code></pre> Tip <p>Consider using PDM or Poetry for project-based dependency management</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>First, create a script from the following template:</p> <pre><code>from ralsei import RalseiCli\ndef make_pipeline(args):\nreturn {} # (1)!\nif __name__ == \"__main__\":\ncli = RalseiCli() # (2)!\ncli.run(make_pipeline)\n</code></pre> <ol> <li> <p>Declare your pipeline here in the format <code>\"name\": Task(...)</code></p> <p>See the Pipeline and Tasks section in Guides</p> </li> <li> <p>Also, you can add custom arguments here, like this:     <pre><code>cli.add_argument(\"-s\", \"--schema\", default=\"orgs\")\n</code></pre></p> <p>See: Custom Arguments</p> </li> </ol> <p>To see some example pipelines, take a look at the Builtin Tasks section of the documentation</p>"},{"location":"#alternatives","title":"Alternatives","text":"<ul> <li>DBT - jinja + SQL based     more suitable for processing data that you already have</li> <li>Kedro - python based,     more suitable for processing data that you already have</li> </ul>"},{"location":"guides/cli/","title":"Cli Usage","text":""},{"location":"guides/cli/#reference","title":"Reference","text":"<p>Each script you create that uses RalseiCli will have the following interface:</p>"},{"location":"guides/cli/#positional-arguments","title":"Positional arguments","text":"<code>task</code> <p>Name of a task or task sequence</p> <code>action</code> <ul> <li><code>run</code></li> <li><code>delete</code></li> <li><code>redo</code> - same as <code>delete</code> + <code>run</code></li> <li><code>describe</code><ul> <li>For a task, prints all the generated SQL scripts</li> <li>For a sequence, prints the (resolved) task names</li> </ul> </li> </ul> <p></p> <p>Output of <code>describe</code> command</p>"},{"location":"guides/cli/#optional-arguments","title":"Optional arguments","text":"<code>db</code> <p>Either a <code>postgres://</code> URL</p> <p>or a json file with the database credentials: <pre><code>{\n\"username\": \"username\",\n\"password\": \"password\",\n\"host\": \"localhost\",\n\"port\": 5432,\n\"database\": \"fsmno\"\n}\n</code></pre></p>"},{"location":"guides/cli/#custom-arguments","title":"Custom Arguments","text":"<p>With RalseiCli.add_argument you can add your own arguments that are then passed to the pipeline factory function:</p> <pre><code>def make_pipeline(args):\nTABLE_pages = Table(\"pages\", args.schema)\n...\nif __name__ == \"__main__\":\ncli = RalseiCli() \ncli.add_argument(\"-s\", \"--schema\", default=\"orgs\")\ncli.run(make_pipeline)\n</code></pre>"},{"location":"guides/map_fn/","title":"Building Function Wrappers","text":""},{"location":"guides/map_fn/#mapping-functions","title":"Mapping Functions","text":"<p>Some tasks require you to specify a mapping function, specifically one of the two kinds:</p>"},{"location":"guides/map_fn/#ralsei.map_fn.protocols.OneToOne","title":"<code>OneToOne = Callable[..., dict]</code>  <code>module-attribute</code>","text":"<p>A function that maps one row to another</p> Example <pre><code>def download(url: str, page: int):\nresponse = requests.get(f\"{url}/{page}\")\nresponse.raise_for_status()\nreturn { \"html\": response.text }\n</code></pre>"},{"location":"guides/map_fn/#ralsei.map_fn.protocols.OneToMany","title":"<code>OneToMany = Callable[..., Iterator[dict]]</code>  <code>module-attribute</code>","text":"<p>A function that maps one row to multiple rows</p> Example <pre><code>def parse(html: str):\nsel = Selector(html)\nfor row in sel.xpath(\"//table/tr\"):\nyield {\n\"name\": sel.xpath(\"td[1]/text()\").get(),\n\"rank\": sel.xpath(\"td[2]/text()\").get(),\n}\n</code></pre>"},{"location":"guides/map_fn/#function-builders","title":"Function Builders","text":"<p>However, if you want to reuse a function across multiple tasks, where the function signature doesn't correspond exactly to the columns, you'll need to make a wrapper function:</p> <pre><code>def download(url: str):\nreturn { \"html\": requests.get(url) }\ndef wrap_download(id: int, url: str):\nreturn { \"id\": id, **download(url) }\nMapToNewColumns(\ntable=TABLE_pages,\nselect=\"SELECT id, html FROM {{table}}\",\ncolumns=[ValueColumn(\"html\", \"TEXT\")],\nid_fields=[IdColumn(\"id\")], # (1)!\nfn=wrap_download,\n)\n</code></pre> <ol> <li>This task generates an UPDATE statement like    <pre><code>UPDATE pages\nSET html = %(html)s\nWHERE id = %(id)s;\n</code></pre>    therefore <code>id</code> value needs to be present in the output</li> </ol> <p>To make wrapping functions less cumbersome, function builders were introduced:</p> <ul> <li>FnBuilder for <code>OneToOne</code></li> <li>and GeneratorBuilder for <code>OneToMany</code>.</li> </ul> <p>The above code block could be replaced with:</p> <pre><code>def download(url: str):\nreturn { \"html\": requests.get(url) }\nMapToNewColumns(\ntable=TABLE_pages,\nselect=\"SELECT id, html FROM {{table}}\",\ncolumns=[ValueColumn(\"html\", \"TEXT\")],\nid_fields=[IdColumn(\"id\")],\nfn=FnBuilder(download).pop_id_fields(\"id\").build(),\n)\n</code></pre>"},{"location":"guides/map_fn/#id_fields-magic","title":"<code>id_fields</code> magic","text":"<p>Notice how there's redundant information here.</p> <p>Most of the time the columns popped will be the identifier columns.</p> <pre><code>MapToNewColumns(\ntable=TABLE_pages,\nselect=\"SELECT id, html FROM {{table}}\",\ncolumns=[ValueColumn(\"html\", \"TEXT\")],\nid_fields=[IdColumn(\"id\")], # redundant\nfn=FnBuilder(download).pop_id_fields(\"id\").build(),\n)\n</code></pre> <p>For this reason the builder object keeps a list of all popped field names.</p> <p>If you omit the <code>build()</code> call and pass the builder object itself, the task will be able to infer <code>id_fields</code> from its metadata.</p> <pre><code>MapToNewColumns(\ntable=TABLE_pages,\nselect=\"SELECT id, html FROM {{table}}\",\ncolumns=[ValueColumn(\"html\", \"TEXT\")],\nfn=FnBuilder(download).pop_id_fields(\"id\"),\n)\n</code></pre>"},{"location":"guides/map_fn/#function-conversion","title":"Function Conversion","text":"<p>In addition, the builders have alternative constructors for converting between regular and generator functions:</p> -------&gt;ToFrom OneToOne OneToMany OneToOne FnBuilder GeneratorBuilder.from_fn OneToMany FnBuilder.from_generator(fails if generator yields more than one item) GeneratorBuilder"},{"location":"guides/map_fn/#wrapper-order","title":"Wrapper order","text":"<p>Keep in mind that the wrappers are applied in the order they are added, meaning that</p> <pre><code>FnBuilder(download)\n.pop_id_fields(\"id\")\n.rename_output({\"id\": \"source_id\"})\n</code></pre> <p>is roughly equivalent to <code>wrap2</code></p> <pre><code>def wrap1(id: int, url: str):\noutput = download(url)\nreturn { \"id\": id, **output }\ndef wrap2(id: int, url: str):\noutput = wrap1(id, url)\nreturn {\n(\"source_id\" if key == \"id\" else key): value\nfor key, value in output.items()\n}\n</code></pre> <p>The opposite order would fail, since <code>id</code> would have already been renamed to <code>source_id</code>.</p>"},{"location":"guides/map_fn/#reference","title":"Reference","text":"<p>Look at <code>FnBuilderBase</code>, the base class of both builders, to see what other methods they have</p>"},{"location":"guides/map_fn/#ralsei.map_fn.builders.FnBuilderBase","title":"<code>FnBuilderBase()</code>","text":"<p>Base class for function wrapper builders</p>"},{"location":"guides/map_fn/#ralsei.map_fn.builders.FnBuilderBase.id_fields","title":"<code>id_fields: Optional[list[str]] = None</code>  <code>instance-attribute</code>","text":"<p>Keeps track of the tasks that were popped using <code>FnBuilderBase.pop_id_fields</code></p> <p>Tasks may use this information to guess which fields uniquely identify a row</p>"},{"location":"guides/map_fn/#ralsei.map_fn.builders.FnBuilderBase.add_wrapper","title":"<code>add_wrapper(wrapper)</code>","text":"<p>Apply a custom wrapper</p> <p>Parameters:</p> <ul> <li> wrapper             (<code>FnWrapper</code>)         \u2013          <p>custom wrapper class</p> </li> </ul>"},{"location":"guides/map_fn/#ralsei.map_fn.builders.FnBuilderBase.pop_id_fields","title":"<code>pop_id_fields(*id_fields, keep=False)</code>","text":"<p>(Optionally) removes fields from the input kwargs and reinserts them back into the output</p> <p>Additionally, <code>*id_fields</code> are appended to <code>self.id_fields</code> list for use in SQL generation</p> <p>Parameters:</p> <ul> <li> *id_fields             (<code>str</code>, default:                 <code>()</code> )         \u2013          <p>fields to pop from the kwargs</p> </li> <li> keep             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>if True, <code>id_fields</code> are not removed from kwargs (but still remembered and reinserted into the output)</p> </li> </ul>"},{"location":"guides/map_fn/#ralsei.map_fn.builders.FnBuilderBase.rename_input","title":"<code>rename_input(remap_fields)</code>","text":"<p>Remaps field names in the <code>**kwargs</code> dictionary</p> <p>Parameters:</p> <ul> <li> remap_fields             (<code>dict[str, str]</code>)         \u2013          <p>old_name -&gt; new_name remap</p> </li> </ul>"},{"location":"guides/map_fn/#ralsei.map_fn.builders.FnBuilderBase.rename_output","title":"<code>rename_output(remap_fields)</code>","text":"<p>Remaps field values in dictionaries generated by the inner function</p> <p>Parameters:</p> <ul> <li> remap_fields             (<code>dict[str, str]</code>)         \u2013          <p>old_name -&gt; new_name remap</p> </li> </ul>"},{"location":"guides/map_fn/#ralsei.map_fn.builders.FnBuilderBase.add_to_input","title":"<code>add_to_input(add_values)</code>","text":"<p>Add extra key-value pairs to input</p> <p>Parameters:</p> <ul> <li> add_values             (<code>dict[str, Any]</code>)         \u2013          <p>field names and values</p> </li> </ul>"},{"location":"guides/map_fn/#ralsei.map_fn.builders.FnBuilderBase.add_to_output","title":"<code>add_to_output(add_values)</code>","text":"<p>Add extra key-value pairs to output</p> <p>Parameters:</p> <ul> <li> add_values             (<code>dict[str, Any]</code>)         \u2013          <p>field names and values</p> </li> </ul>"},{"location":"guides/pipeline/","title":"Declaring your Pipeline","text":"<p>You declare your pipeline as a dictionary in a pipeline factory function that receives argparse.Namespace, the cli arguments, as its input.</p> <pre><code>def make_pipeline(args):\nreturn {\n\"make_urls\": MapToNewTable(...),\n\"download\": MapToNewColumns(...),\n\"extract\": CreateTableSql(...),\n}\n</code></pre> <p>In the example above, 3 named tasks are created, as well as a hidden <code>__full__</code> sequence that runs those tasks in the order they were defined.</p> <p>If needed, you can explicitly define <code>__full__</code> as well as other sequences. Let's say that there are 2 variants of the <code>extract</code> task: one for the older and one the newer version of a website.</p> <pre><code>def make_pipeline(args):\nreturn {\n\"make_urls\": MapToNewTable(...),\n\"download\": MapToNewColumns(...),\n\"extract1\": AddColumnsSql(...),\n\"extract2\": CreateTableSql(...),\n\"old\": [\n\"make_urls\",\n\"download\",\n\"extract1\"\n],\n\"__full__\": [\n\"make_urls\",\n\"download\",\n\"extract2\"\n]\n}\n</code></pre> <ul> <li>So, you could run <code>script.py __full__ run</code> for the new version,</li> <li><code>script.py old run</code> for the old version,</li> <li>or run any of the tasks individially.</li> </ul> <p>When running a sequence, it only executes the tasks that haven't been done yet.</p> <p>Warning</p> <p>Note that the pipeline at the moment does not resolve dependencies and put tasks in the correct order.</p> <p>They simply run in the order they are defined.</p>"},{"location":"guides/tasks/","title":"Declaring Tasks","text":"<p>Tasks are individial database actions that you can run, revert or check the status of. They build your dataset piece by piece, usually by:</p> <ul> <li>creating a new table and filling it with data</li> <li>adding columns to an existing table and filling them with data</li> </ul> <p>In most cases, you can compose your data pipeline just out of 4 Builtin Tasks:</p> Written in Create Table Add Columns SQL CreateTableSql AddColumnsSql Python MapToNewTable MapToNewColumns <p>However, if you need a dynamically generated table, where the columns aren't known in advance, or a task with multiple outputs, you may want to write your own Task.</p>"},{"location":"guides/tasks/#builtin-tasks","title":"Builtin Tasks","text":""},{"location":"guides/tasks/#ralsei.task.create_table_sql.CreateTableSql","title":"<code>CreateTableSql(sql, table, params={}, view=False)</code>","text":"<p>             Bases: <code>Task</code></p> <p>Runs a <code>CREATE TABLE</code> sql script</p> <p>Parameters:</p> <ul> <li> sql             (<code>str</code>)         \u2013          <p>sql template string</p> </li> <li> table             (<code>Table</code>)         \u2013          <p>Table being created</p> </li> <li> params             (<code>dict</code>, default:                 <code>{}</code> )         \u2013          <p>parameters passed to the jinja template</p> </li> <li> view             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>whether this is a VIEW instead of a TABLE</p> </li> </ul> Template <p>Environment variables: <code>table</code>, <code>**params</code></p> Example unnest.sql<pre><code>CREATE TABLE {{table}}(\nid SERIAL PRIMARY KEY,\nname TEXT\n);\nINSERT INTO {{table}}(name)\nSELECT json_array_elements_text(json-&gt;'names')\nFROM {{sources}};\n</code></pre> pipeline.py<pre><code>\"unnest\": CreateTableSql(\nsql=Path(\"./unnest.sql\").read_text(),\ntable=TABLE_names,\nparams={\"table\": TABLE_sources},\n)\n</code></pre>"},{"location":"guides/tasks/#ralsei.task.add_columns_sql.AddColumnsSql","title":"<code>AddColumnsSql(sql, table, columns=None, params={})</code>","text":"<p>             Bases: <code>Task</code></p> <p>Adds the specified Columns to an existing Table and runs the SQL script to fill them with data</p> <p>Parameters:</p> <ul> <li> sql             (<code>str</code>)         \u2013          <p>sql template string</p> </li> <li> table             (<code>Table</code>)         \u2013          <p>Table to add columns to</p> </li> <li> columns             (<code>Optional[list[Column]]</code>, default:                 <code>None</code> )         \u2013          <p>these column definitions take precedence over those defined in the template</p> </li> <li> params             (<code>dict</code>, default:                 <code>{}</code> )         \u2013          <p>parameters passed to the jinja template</p> </li> </ul> Template <p>Environment variables: <code>table</code>, <code>**params</code></p> <p>Columns can be defined in the template itself, using <code>{% set columns = [...] %}</code></p> Example postprocess.sql<pre><code>{% set columns = [Column(\"name_upper\", \"TEXT\")] %}\nUPDATE {{table}}\nSET name_upper = UPPER(name);\n</code></pre> pipeline.py<pre><code>\"postprocess\": AddColumnsSql(\nsql=Path(\"./postprocess.sql\").read_text(),\ntable=TABLE_people,\n)\n</code></pre>"},{"location":"guides/tasks/#ralsei.task.map_to_new_table.MapToNewTable","title":"<code>MapToNewTable(table, columns, fn, select=None, source_table=None, is_done_column=None, id_fields=None, params={}, cursor_factory=ClientCursorFactory())</code>","text":"<p>             Bases: <code>Task</code></p> <p>Applies the provided map function to a query result, mapping a single row to one or more rows in a new table</p> <p>Parameters:</p> <ul> <li> table             (<code>Table</code>)         \u2013          <p>The new table being created</p> </li> <li> columns             (<code>list[str | ValueColumn]</code>)         \u2013          <p>Columns (and constraints) that make up the table definition.</p> <p>Additionally, <code>ValueColumn</code>s <code>value</code> field is used in the generation of the <code>INSERT</code> statement (if not specified, <code>value</code> will be set to a SQL Placeholder with the same name as the column).</p> <p><code>str</code> columns and <code>ValueColumn.type</code> string are passed through the jinja preprocessor.</p> </li> <li> fn             (<code>OneToMany | GeneratorBuilder</code>)         \u2013          <p>A generator function, mapping one row to many rows.</p> <p>If a function builder was passed instead of the function itself,   the task will try to infer the table's <code>id_fields</code> from its metadata</p> </li> <li> select             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>The <code>SELECT</code> statement that generates the input rows passed to function <code>fn</code> as arguments.</p> <p>If not specified, <code>fn</code> will only run once with 0 arguments.</p> </li> <li> source_table             (<code>Optional[Table]</code>, default:                 <code>None</code> )         \u2013          <p>The table that the input rows come from. Only useful if you want to create <code>is_done_column</code>.</p> </li> <li> is_done_column             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>Create a boolean column with the given name in <code>source_table</code> that tracks which rows have been processed.</p> <p>If specified, the task will commit after each successful run of <code>fn</code>, allowing you to stop and resume from the same place.</p> <p>Make sure to include <code>WHERE NOT {{is_done}}</code> in your <code>select</code> statement</p> </li> <li> id_fields             (<code>Optional[list[IdColumn]]</code>, default:                 <code>None</code> )         \u2013          <p>Columns that uniquely identify a row in <code>source_table</code>. Only useful if you want to create <code>is_done_column</code>.</p> <p>This argument takes precedence over the <code>id_fields</code> inferred from <code>GeneratorBuilder</code>'s metadata</p> </li> <li> params             (<code>dict</code>, default:                 <code>{}</code> )         \u2013          <p>parameters passed to the jinja template</p> </li> <li> cursor_factory             (<code>CursorFactory</code>, default:                 <code>ClientCursorFactory()</code> )         \u2013          <p>if the number of rows generated by <code>select</code> is too large to fit into memory, you can use ralsei.ServerCursorFactory</p> </li> </ul> Template <p>Environment variables:</p> <ul> <li><code>table</code>: equals to <code>table</code> argument</li> <li><code>source</code>: equals to <code>source_table</code> argument</li> <li><code>is_done</code>: equals to <code>is_done_column</code> argument</li> <li><code>**params</code></li> </ul> Example <pre><code># Find subjects on the hub page\ndef find_subjects(hub_url: str):\nhtml = download(hub_url)\nsel = Selector(html)\nfor row in sel.xpath(\"//table/tr\"):\nyield {\n\"subject\": row.xpath(\"a/text()\").get(),\n\"url\": row.xpath(\"a/@href\").get()\n}\n# Download all pages in a subject rating\ndef download_pages(url: str):\nnext_url = url\npage = 1\nwhile next_url is not None:\nhtml = download(next_url)\nyield { \"page\": page, \"html\": html }\nsel = Selector(html)\nnext_url = sel.xpath(\"//a[@id = 'next']\").get()\npage += 1\ncli.run({\n\"subjects\": MapToNewTable(\ntable=TABLE_subjects,\ncolumns=[ # (1)!\n\"id SERIAL PRIMARY KEY\",\nValueColumn(\"subject\", \"TEXT\"),\nValueColumn(\"url\", \"TEXT\"),\n],\nfn=GeneratorBuilder(find_subjects).add_to_input( # (2)!\n{ \"hub_url\": \"https://rating.com/2022\" }\n)\n),\n\"pages\": MapToNewTable(\nsource_table=TABLE_subjects,\nselect=\"\"\"\\\n        SELECT id, url FROM {{source}}\n        WHERE NOT {{is_done}}\"\"\", # (3)!\ncolumns=[\nValueColumn(\n\"subject_id\",\n\"INT REFERENCES {{source}}(id)\", # (4)!\nPlaceholder(\"id\")\n),\nValueColumn(\"page\", \"INT\"),\nValueColumn(\"html\", \"TEXT\"),\n\"date_downloaded DATE DEFAULT NOW()\",\n],\nis_done_column=\"__downloaded\", # (5)!\nfn=GeneratorBuilder(download_pages)\n.pop_id_fields(\"id\") # (6)!\n)\n})\n</code></pre> <ol> <li> <p>Table body is generated from all <code>columns</code>,    INSERT statement - only from <code>ValueColumn</code>s</p> </li> <li> <p>Since there is no SELECT statement,    you have to transform <code>find_subjects</code>    into a function that takes 0 arguments</p> </li> <li> <p>Filter out subjects that have already been downloaded</p> </li> <li> <p>jinja templates are allowed</p> </li> <li> <p>Column <code>__downloaded</code> will be added to <code>TABLE_subjects</code></p> </li> <li> <p>This serves 2 purposes:    1) Removes <code>id</code> from the arguments    of <code>download_pages</code> and later attaches    it to its output rows    2) Allows the task to infer that <code>id</code>    uniquely identifies <code>source_table</code> rows.    If not true, you can override this    with ihe <code>id_fields</code> argument</p> </li> </ol>"},{"location":"guides/tasks/#ralsei.task.map_to_new_columns.MapToNewColumns","title":"<code>MapToNewColumns(select, table, columns, fn, is_done_column=None, id_fields=None, params={}, cursor_factory=ClientCursorFactory())</code>","text":"<p>             Bases: <code>Task</code></p> <p>Applies the provided map function to a query result, saving outputs into new columns on the same row</p> <p>Parameters:</p> <ul> <li> select             (<code>str</code>)         \u2013          <p>the <code>SELECT</code> statement that generates the input rows passed to function <code>fn</code> as arguments</p> </li> <li> table             (<code>Table</code>)         \u2013          <p>Table to add columns to</p> </li> <li> columns             (<code>list[ValueColumn]</code>)         \u2013          <p>a list of <code>ValueColumn</code>s used for <code>ADD COLUMN</code> and <code>UPDATE</code> statement generation.</p> </li> <li> fn             (<code>OneToOne | FnBuilder</code>)         \u2013          <p>A function that maps one row to values of the new columns in the same row.</p> <p>If a function builder was passed instead of the function itself, the task will try to infer the table's <code>id_fields</code> from its metadata</p> </li> <li> is_done_column             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>create a boolean column with the given name in <code>table</code> that tracks which rows have been processed.</p> <p>If specified, the task will commit after each successful run of <code>fn</code>, allowing you to stop and resume from the same place.</p> <p>Make sure to include <code>WHERE NOT {{is_done}}</code> in your <code>select</code> statement</p> </li> <li> id_fields             (<code>Optional[list[IdColumn]]</code>, default:                 <code>None</code> )         \u2013          <p>columns that uniquely identify a row in <code>table</code>.</p> <p>This argument takes precedence over the <code>id_fields</code> inferred from <code>FnBuilder</code>'s metadata</p> </li> <li> params             (<code>dict</code>, default:                 <code>{}</code> )         \u2013          <p>parameters passed to the jinja template</p> </li> <li> cursor_factory             (<code>CursorFactory</code>, default:                 <code>ClientCursorFactory()</code> )         \u2013          <p>if the number of rows generated by <code>select</code> is too large to fit into memory, you can use ralsei.ServerCursorFactory</p> </li> </ul> Template <p>Environment variables:</p> <ul> <li><code>table</code>: equals to <code>table</code> argument</li> <li><code>is_done</code>: equals to <code>is_done_column</code> argument</li> </ul> Example <pre><code>from psycopg.sql import SQL\ndef download(url: str):\nresponse = requests.get(url)\nresponse.raise_for_status()\nreturn { \"html\": response.text() }\ndef parse(html: str):\nsel = Selector(html)\nreturn {\n\"title\": sel.xpath(\"//h1/text()\").get(),\n\"rating\": sel.xpath(\"//div[@id='rating']/text()\").get()\n}\ncli.run({\n\"download\": MapToNewColumns(\ntable=TABLE_pages,\nselect=\"SELECT id, url FROM {{table}} WHERE NOT {{is_done}}\", # (1)!\ncolumns=[\nValueColumn(\"html\", \"TEXT\"), # (2)!\nValueColumn(\"date_downloaded\", \"DATE\", SQL(\"NOW()\")), # (3)!\n],\nis_done_column=\"__downloaded\", # (4)!\nfn=FnBuilder(download).pop_id_fields(\"id\"), # (5)!\n),\n\"parse\": MapToNewColumns(\ntable=TABLE_pages,\nselect=\"SELECT id, html FROM {{table}}\",\ncolumns=[\nValueColumn(\"title\", \"TEXT\"),\nValueColumn(\"rating\", \"TEXT\"),\n],\nfn=FnBuilder(parse).pop_id_fields(\"id\")\n),\n})\n</code></pre> <ol> <li>Filter out pages that have already been downloaded</li> <li>This column's value will be determined by <code>download</code> function</li> <li>Overriding the value</li> <li>Add a boolean column for tracking the progress</li> <li>This serves 2 purposes:    1) Removes <code>id</code> from the arguments    of <code>download</code> and later attaches    it to its output dict    2) Allows the task to infer that <code>id</code>    uniquely identifies <code>table</code> rows.    If not true, you can override this    with ihe <code>id_fields</code> argument</li> </ol>"},{"location":"guides/tasks/#custom-task","title":"Custom Task","text":"<p>Let's create a task that reorganizes a table consisting of \"index\", \"key\" and \"value\" columns into one where columns are dynamically generated from \"key\" values, a so-called pivot table:</p> <pre><code>CreatePivotTable(\nselect=\"SELECT index, key, value, FROM {{source}}\", # (1)!\nparams={ \"source\": table_stacked }, # (2)!\ntable=table_pivot, # (3)!\nindex=\"index\", # (4)!\ncolumn=\"key\",\nvalue=\"value\",\n)\n</code></pre> <ol> <li>Since this is a jinja template, you can even have more complex expressions:     <pre><code>select=\"\"\"\\\nSELECT index, key, valye FROM {{source}}\n{%- if limit %} LIMIT {{ limit }}{% endif %}\"\"\",\nparams={ \"source\": TABLE_b, \"limit\": args.limit }\n</code></pre></li> <li>Parameters passed to the jinja template</li> <li>The table being created</li> <li>Arguments passed to pandas.DataFrame.pivot</li> </ol> table_stacked table_pivot index key value 1 A 1 1 B 2 1 C 3 2 A 4 2 B 5 2 C 6 index A B C 1 1 2 3 2 4 5 6"},{"location":"guides/tasks/#implementation","title":"Implementation","text":"<p>To start, import building blocks from the common module, <pre><code>from ralsei.task.common import (\nTask, # base class\nTable, # db table\nPsycopgConn, # db connection\nRalseiRenderer, # jinja renderer\nchecks, # existence checks\n)\n</code></pre></p> <p>Create a Task subclass and save the arguments for later</p> <pre><code>class CreatePivotTable(Task):\ndef __init__(\nself,\ntable: Table,\nselect: str,\nindex: str | list[str],\ncolumn: str,\nvalue: str,\nparams: dict = {},\n):\nsuper().__init__() # required\nself._table = table\nself._raw_select = select\nself._params = params\nself._pivot_index = index\nself._pivot_column = column\nself._pivot_value = value\n</code></pre> Tip <p>Or use the attrs package so that you don't have to write the constructor</p> <p>Now, override the necessary methods:</p> <p>Save the rendered SQL in <code>self.scripts</code> if you want it to be printed by the <code>describe</code> cli command</p> <pre><code>    def render(self, renderer: RalseiRenderer) -&gt; None:\nself.scripts[\"Select\"] = self._select = renderer.render(\nself._raw_select, self._params\n)\nself.scripts[\"Drop\"] = self._drop = renderer.render(\n\"DROP TABLE {{table}};\", {\"table\": self._table}\n)\n</code></pre> <p>Note that you can access both the underlying <code>psycopg</code> connection (can work with Composed objects and execute raw sql)</p> <p>as well as its <code>sqlalchemy</code> wrapper (for compatibility with pandas and the like)</p> <pre><code>    def run(self, conn: PsycopgConn) -&gt; None:\nsource_table = pd.read_sql_query( # (1)!\nself._select.as_string(conn.pg), # (2)!\nconn.sqlalchemy, # (3)!\n)\npivot = source_table.pivot( # (4)!\nindex=self._pivot_index,\ncolumns=self._pivot_column,\nvalues=self._pivot_value,\n).reset_index()\npivot.to_sql( # (5)!\nself._table.name,\nconn.sqlalchemy,\nschema=self._table.schema,\n)\n</code></pre> <ol> <li> <p>Load a DataFrame from sql</p> <p>See pandas.read_sql_query</p> </li> <li> <p>The Composed object     needs to be converted into a string by the backend</p> </li> <li> <p>pandas only accepts the sqlalchemy connection</p> </li> <li> <p>That's where the magic happens.</p> <p>See pandas.DataFrame.pivot</p> </li> <li> <p>Save table to the database.</p> <p>See pandas.DataFrame.to_sql</p> </li> </ol> <p>To check a table's existence you can use one of the builtin functions in ralsei.checks</p> <pre><code>    def exists(self, conn: PsycopgConn) -&gt; bool:\nreturn checks.table_exists(conn, self._table)\n</code></pre> <pre><code>    def delete(self, conn: PsycopgConn) -&gt; None:\nconn.pg.execute(self._drop)\n</code></pre>"},{"location":"guides/tasks/#ralsei.task.base.Task.render","title":"<code>render(renderer)</code>","text":"<p>Render your sql scripts here, like this: <pre><code>self.scripts[\"Create table\"] = self.__create_table = renderer.render(...)\n</code></pre></p> <p>This methon runs before <code>run</code> and <code>delete</code></p> <p>Parameters:</p> <ul> <li> renderer             (<code>RalseiRenderer</code>)         \u2013          <p>jinja sql renderer</p> </li> </ul>"},{"location":"guides/tasks/#ralsei.task.base.Task.run","title":"<code>run(conn)</code>  <code>abstractmethod</code>","text":"<p>Execute the task</p> <p>Parameters:</p> <ul> <li> conn             (<code>PsycopgConn</code>)         \u2013          <p>db connection</p> </li> </ul>"},{"location":"guides/tasks/#ralsei.task.base.Task.exists","title":"<code>exists(conn)</code>  <code>abstractmethod</code>","text":"<p>Check if task has already been done</p> <p>Parameters:</p> <ul> <li> conn             (<code>PsycopgConn</code>)         \u2013          <p>db connection</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>has been done?</p> </li> </ul>"},{"location":"guides/tasks/#ralsei.task.base.Task.delete","title":"<code>delete(conn)</code>  <code>abstractmethod</code>","text":"<p>Delete whatever <code>run()</code> method has created</p> <p>Parameters:</p> <ul> <li> conn             (<code>PsycopgConn</code>)         \u2013          <p>db connection</p> </li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>ralsei<ul> <li>_pipeline</li> <li>checks</li> <li>cli</li> <li>connection</li> <li>cursor_factory</li> <li>map_fn<ul> <li>builders</li> <li>protocols</li> <li>wrappers</li> </ul> </li> <li>renderer</li> <li>task<ul> <li>add_columns_sql</li> <li>base</li> <li>common</li> <li>create_table_sql</li> <li>map_to_new_columns</li> <li>map_to_new_table</li> </ul> </li> <li>templates<ul> <li>column</li> <li>table</li> <li>value_column</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/ralsei/","title":"Index","text":""},{"location":"reference/ralsei/#ralsei","title":"<code>ralsei</code>","text":""},{"location":"reference/ralsei/_pipeline/","title":"_pipeline","text":""},{"location":"reference/ralsei/_pipeline/#ralsei._pipeline","title":"<code>_pipeline</code>","text":"Warning <p>This module is experimental and will change!</p>"},{"location":"reference/ralsei/_pipeline/#ralsei._pipeline.TaskDefinitions","title":"<code>TaskDefinitions = MutableMapping[str, Task | list[str]]</code>  <code>module-attribute</code>","text":"<p>A dictionary mapping names to tasks or sequences of tasks.</p> <p>There is also an implied sequence named <code>__full__</code> that, by default, will contain keys of this dictionary in the order they were defined. You can override the <code>__full__</code> sequence by explicitly defining it, such as to exclude some tasks or change their order.</p> Example <pre><code>definitions = {\n\"make_urls\": MapToNewTable(...),\n\"download\": MapToNewColumns(...),\n\"extract1\": AddColumnsSql(...),\n\"extract2\": CreateTableSql(...),\n\"old\": [\n\"make_urls\",\n\"download\",\n\"extract1\"\n],\n\"__full__\": [ # If defined, will default to list(definitions.keys())\n\"make_urls\",\n\"download\",\n\"extract2\"\n]\n}\n</code></pre>"},{"location":"reference/ralsei/checks/","title":"checks","text":""},{"location":"reference/ralsei/checks/#ralsei.checks","title":"<code>checks</code>","text":"<p>Checks for table/column's existence</p> <p>You can use these to implement ralsei.task.Task.exists</p>"},{"location":"reference/ralsei/checks/#ralsei.checks.table_exists","title":"<code>table_exists(conn, table, view=False)</code>","text":"<p>Parameters:</p> <ul> <li> conn             (<code>PsycopgConn</code>)         \u2013          <p>db connection</p> </li> <li> table             (<code>Table</code>)         \u2013          <p>table name and schema</p> </li> <li> view             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>whether this is a VIEW instead of a TABLE</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if table exists, False otherwise</p> </li> </ul>"},{"location":"reference/ralsei/checks/#ralsei.checks.column_exists","title":"<code>column_exists(conn, table, column)</code>","text":"<p>Parameters:</p> <ul> <li> conn             (<code>PsycopgConn</code>)         \u2013          <p>db connection</p> </li> <li> table             (<code>Table</code>)         \u2013          <p>table name and schema</p> </li> <li> column             (<code>str</code>)         \u2013          <p>column name</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if column exists, False otherwise</p> </li> </ul>"},{"location":"reference/ralsei/checks/#ralsei.checks.columns_exist","title":"<code>columns_exist(conn, table, columns)</code>","text":"<p>Parameters:</p> <ul> <li> conn             (<code>PsycopgConn</code>)         \u2013          <p>db connection</p> </li> <li> table             (<code>Table</code>)         \u2013          <p>table name and schema</p> </li> <li> columns             (<code>Iterable[str]</code>)         \u2013          <p>column names</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if all column exist, False otherwise</p> </li> </ul>"},{"location":"reference/ralsei/cli/","title":"cli","text":""},{"location":"reference/ralsei/cli/#ralsei.cli","title":"<code>cli</code>","text":""},{"location":"reference/ralsei/cli/#ralsei.cli.RalseiCli","title":"<code>RalseiCli()</code>","text":"<p>Command line interface for running ralsei pipelines</p>"},{"location":"reference/ralsei/cli/#ralsei.cli.RalseiCli.add_argument","title":"<code>add_argument = custom_group.add_argument</code>  <code>instance-attribute</code>","text":"<p>Mimics argparse.ArgumentParser.add_argument</p> <pre><code>add_argument(\n    name or flags...\n    [, action][, nargs][, const][, default][, type]\n    [, choices][, required][, help][, metavar][, dest]\n)\n</code></pre>"},{"location":"reference/ralsei/cli/#ralsei.cli.RalseiCli.run","title":"<code>run(task_tree, credentials=None)</code>","text":"<p>Parse arguments and run the corresponding tasks</p> <p>Parameters:</p> <ul> <li> task_tree             (<code>TaskDefinitions | Callable[[Namespace], TaskDefinitions]</code>)         \u2013          <p>a dictionary declaring the tasks or a function that receives the cli arguments and creates said dictionary</p> </li> <li> credentials             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>either <code>postgres://</code> url or a path to json file</p> </li> </ul>"},{"location":"reference/ralsei/connection/","title":"connection","text":""},{"location":"reference/ralsei/connection/#ralsei.connection","title":"<code>connection</code>","text":""},{"location":"reference/ralsei/connection/#ralsei.connection.PsycopgConn","title":"<code>PsycopgConn(conn)</code>","text":"<p>A wrapper over sqlalchemy.engine.Connection that is guaranteed to be using the psycopg3 driver</p> <p>Parameters:</p> <ul> <li> conn             (<code>Connection</code>)         \u2013          <p>sqlalchemy connection</p> </li> </ul>"},{"location":"reference/ralsei/connection/#ralsei.connection.PsycopgConn.sqlalchemy","title":"<code>sqlalchemy: SqlalchemyConn</code>  <code>property</code>","text":"<p>Returns:</p> <ul> <li> <code>Connection</code>         \u2013          <p>sqlalchemy connection</p> </li> </ul> Example <p>Can be used for pandas interop: <pre><code>pd.read_sql_query(\"SELECT * FROM orgs\", conn.sqlalchemy)\n</code></pre></p>"},{"location":"reference/ralsei/connection/#ralsei.connection.PsycopgConn.pg","title":"<code>pg: psycopg.Connection</code>  <code>property</code>","text":"<p>Returns:</p> <ul> <li> <code>Connection</code>         \u2013          <p>the raw psycopg connection</p> </li> </ul> Example <p>Can be used for executing/displaying composed sql <pre><code>renderer.render(\n\"SELECT * FROM {{table}}\",\n{\"table\": Table(\"orgs\", \"dev\")}\n).as_string(conn.pg)\n</code></pre></p>"},{"location":"reference/ralsei/connection/#ralsei.connection.create_connection_url","title":"<code>create_connection_url(credentials)</code>","text":"<p>Creates sqlalchemy url from either a url or a json path,     ensuring that the <code>psycopg</code> driver is used</p> <p>Parameters:</p> <ul> <li> credentials             (<code>str</code>)         \u2013          <p>either a <code>postgres://</code> type URL or a json path</p> <p>Json example: <pre><code>{\n\"username\": \"username\",\n\"password\": \"password\",\n\"host\": \"localhost\",\n\"port\": 5432,\n\"database\": \"fsmno\"\n}\n</code></pre></p> </li> </ul> <p>Returns:     url for creating sqlalchemy engine</p>"},{"location":"reference/ralsei/cursor_factory/","title":"cursor_factory","text":""},{"location":"reference/ralsei/cursor_factory/#ralsei.cursor_factory","title":"<code>cursor_factory</code>","text":""},{"location":"reference/ralsei/cursor_factory/#ralsei.cursor_factory.CursorFactory","title":"<code>CursorFactory</code>","text":"<p>             Bases: <code>ABC</code></p>"},{"location":"reference/ralsei/cursor_factory/#ralsei.cursor_factory.CursorFactory.create_cursor","title":"<code>create_cursor(conn, withhold)</code>  <code>abstractmethod</code>","text":"<p>Creates a (client- or server-side) psycopg.Cursor</p> <p>Parameters:</p> <ul> <li> conn             (<code>Connection</code>)         \u2013          <p>connection</p> </li> <li> withhold             (<code>bool</code>)         \u2013          <p>if the cursor can be used after committing a transaction, see psycopg.ServerCursor.withhold</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Cursor</code>         \u2013          <p>cursor, must use row_factory=dict_row</p> </li> </ul>"},{"location":"reference/ralsei/cursor_factory/#ralsei.cursor_factory.ClientCursorFactory","title":"<code>ClientCursorFactory</code>","text":"<p>             Bases: <code>CursorFactory</code></p> <p>The default cursor factory, creates an in-memory cursor</p>"},{"location":"reference/ralsei/cursor_factory/#ralsei.cursor_factory.ServerCursorFactory","title":"<code>ServerCursorFactory(name='input_cursor', itersize=None)</code>","text":"<p>             Bases: <code>CursorFactory</code></p> <p>Use this if the number of rows is too large to fit into memory</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>, default:                 <code>'input_cursor'</code> )         \u2013          <p>how to name this cursor on the backend</p> </li> <li> itersize             (<code>Optional[int]</code>, default:                 <code>None</code> )         \u2013          <p>how many rows to load into memory at once</p> </li> </ul>"},{"location":"reference/ralsei/renderer/","title":"renderer","text":""},{"location":"reference/ralsei/renderer/#ralsei.renderer","title":"<code>renderer</code>","text":""},{"location":"reference/ralsei/renderer/#ralsei.renderer.RalseiRenderer","title":"<code>RalseiRenderer</code>","text":"<p>             Bases: <code>JinjaPsycopg</code></p> <p>Jinja+Psycopg renderer pre-initialized with ralsei's environment variables</p> <p>See JinjaPsycopg's page for usage</p>"},{"location":"reference/ralsei/map_fn/","title":"Index","text":""},{"location":"reference/ralsei/map_fn/#ralsei.map_fn","title":"<code>map_fn</code>","text":"<p>Utilities for building wrappers around a function, such as:</p> <ul> <li>renaming an key in <code>**kwargs</code></li> <li>renaming a key in the returned/yielded dictionaries</li> <li>popping a key from input and re-attaching it to the output</li> <li>adding arguments to the input, etc..</li> </ul> <p>You'll most likely be using ralsei.map_fn.FnBuilder for simple functions and ralsei.map_fn.GeneratorBuilder for generator functions</p>"},{"location":"reference/ralsei/map_fn/builders/","title":"builders","text":""},{"location":"reference/ralsei/map_fn/builders/#ralsei.map_fn.builders","title":"<code>builders</code>","text":""},{"location":"reference/ralsei/map_fn/builders/#ralsei.map_fn.builders.FnBuilderBase","title":"<code>FnBuilderBase()</code>","text":"<p>Base class for function wrapper builders</p>"},{"location":"reference/ralsei/map_fn/builders/#ralsei.map_fn.builders.FnBuilderBase.id_fields","title":"<code>id_fields: Optional[list[str]] = None</code>  <code>instance-attribute</code>","text":"<p>Keeps track of the tasks that were popped using <code>FnBuilderBase.pop_id_fields</code></p> <p>Tasks may use this information to guess which fields uniquely identify a row</p>"},{"location":"reference/ralsei/map_fn/builders/#ralsei.map_fn.builders.FnBuilderBase.add_wrapper","title":"<code>add_wrapper(wrapper)</code>","text":"<p>Apply a custom wrapper</p> <p>Parameters:</p> <ul> <li> wrapper             (<code>FnWrapper</code>)         \u2013          <p>custom wrapper class</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/builders/#ralsei.map_fn.builders.FnBuilderBase.pop_id_fields","title":"<code>pop_id_fields(*id_fields, keep=False)</code>","text":"<p>(Optionally) removes fields from the input kwargs and reinserts them back into the output</p> <p>Additionally, <code>*id_fields</code> are appended to <code>self.id_fields</code> list for use in SQL generation</p> <p>Parameters:</p> <ul> <li> *id_fields             (<code>str</code>, default:                 <code>()</code> )         \u2013          <p>fields to pop from the kwargs</p> </li> <li> keep             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>if True, <code>id_fields</code> are not removed from kwargs (but still remembered and reinserted into the output)</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/builders/#ralsei.map_fn.builders.FnBuilderBase.rename_input","title":"<code>rename_input(remap_fields)</code>","text":"<p>Remaps field names in the <code>**kwargs</code> dictionary</p> <p>Parameters:</p> <ul> <li> remap_fields             (<code>dict[str, str]</code>)         \u2013          <p>old_name -&gt; new_name remap</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/builders/#ralsei.map_fn.builders.FnBuilderBase.rename_output","title":"<code>rename_output(remap_fields)</code>","text":"<p>Remaps field values in dictionaries generated by the inner function</p> <p>Parameters:</p> <ul> <li> remap_fields             (<code>dict[str, str]</code>)         \u2013          <p>old_name -&gt; new_name remap</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/builders/#ralsei.map_fn.builders.FnBuilderBase.add_to_input","title":"<code>add_to_input(add_values)</code>","text":"<p>Add extra key-value pairs to input</p> <p>Parameters:</p> <ul> <li> add_values             (<code>dict[str, Any]</code>)         \u2013          <p>field names and values</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/builders/#ralsei.map_fn.builders.FnBuilderBase.add_to_output","title":"<code>add_to_output(add_values)</code>","text":"<p>Add extra key-value pairs to output</p> <p>Parameters:</p> <ul> <li> add_values             (<code>dict[str, Any]</code>)         \u2013          <p>field names and values</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/builders/#ralsei.map_fn.builders.GeneratorBuilder","title":"<code>GeneratorBuilder(fn)</code>","text":"<p>             Bases: <code>FnBuilderBase</code></p> <p>Build a function that maps one row to many rows</p> <p>Parameters:</p> <ul> <li> fn             (<code>OneToMany</code>)         \u2013          <p>base function to build wrappers around</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/builders/#ralsei.map_fn.builders.GeneratorBuilder.from_fn","title":"<code>from_fn(fn)</code>  <code>staticmethod</code>","text":"<p>Create from a one-to-one function by converting it into a generator function</p> <p>Parameters:</p> <ul> <li> fn             (<code>OneToOne</code>)         \u2013          <p>base function to build wrappers around</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeneratorBuilder</code>         \u2013          <p>self</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/builders/#ralsei.map_fn.builders.GeneratorBuilder.build","title":"<code>build()</code>","text":"<p>Apply all wrappers</p> <p>Returns:</p> <ul> <li> <code>OneToMany</code>         \u2013          <p>the wrapped function</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/builders/#ralsei.map_fn.builders.FnBuilder","title":"<code>FnBuilder(fn)</code>","text":"<p>             Bases: <code>FnBuilderBase</code></p> <p>Build a one-to-one mapping function</p> <p>Parameters:</p> <ul> <li> fn             (<code>OneToOne</code>)         \u2013          <p>base function to build wrappers around</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/builders/#ralsei.map_fn.builders.FnBuilder.from_generator","title":"<code>from_generator(fn)</code>  <code>staticmethod</code>","text":"<p>Create from a generator function that yields a single value</p> <p>Parameters:</p> <ul> <li> fn             (<code>OneToMany</code>)         \u2013          <p>base function to build wrappers around</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>FnBuilder</code>         \u2013          <p>self</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>If there's more than one value in the generator</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/builders/#ralsei.map_fn.builders.FnBuilder.build","title":"<code>build()</code>","text":"<p>Apply all wrappers</p> <p>Returns:</p> <ul> <li> <code>OneToOne</code>         \u2013          <p>the wrapped function</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/protocols/","title":"protocols","text":""},{"location":"reference/ralsei/map_fn/protocols/#ralsei.map_fn.protocols","title":"<code>protocols</code>","text":""},{"location":"reference/ralsei/map_fn/protocols/#ralsei.map_fn.protocols.OneToOne","title":"<code>OneToOne = Callable[..., dict]</code>  <code>module-attribute</code>","text":"<p>A function that maps one row to another</p> Example <pre><code>def download(url: str, page: int):\nresponse = requests.get(f\"{url}/{page}\")\nresponse.raise_for_status()\nreturn { \"html\": response.text }\n</code></pre>"},{"location":"reference/ralsei/map_fn/protocols/#ralsei.map_fn.protocols.OneToMany","title":"<code>OneToMany = Callable[..., Iterator[dict]]</code>  <code>module-attribute</code>","text":"<p>A function that maps one row to multiple rows</p> Example <pre><code>def parse(html: str):\nsel = Selector(html)\nfor row in sel.xpath(\"//table/tr\"):\nyield {\n\"name\": sel.xpath(\"td[1]/text()\").get(),\n\"rank\": sel.xpath(\"td[2]/text()\").get(),\n}\n</code></pre>"},{"location":"reference/ralsei/map_fn/wrappers/","title":"wrappers","text":""},{"location":"reference/ralsei/map_fn/wrappers/#ralsei.map_fn.wrappers","title":"<code>wrappers</code>","text":""},{"location":"reference/ralsei/map_fn/wrappers/#ralsei.map_fn.wrappers.FnWrapper","title":"<code>FnWrapper</code>","text":"<p>             Bases: <code>ABC</code></p>"},{"location":"reference/ralsei/map_fn/wrappers/#ralsei.map_fn.wrappers.FnWrapper.wrap","title":"<code>wrap(fn)</code>  <code>abstractmethod</code>","text":"<p>Apply a wrapper to fn</p> <p>Parameters:</p> <ul> <li> fn             (<code>OneToMany</code>)         \u2013          <p>inner function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OneToMany</code>         \u2013          <p>wrapped function</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/wrappers/#ralsei.map_fn.wrappers.PopIdFields","title":"<code>PopIdFields(*id_fields, keep=False)</code>","text":"<p>             Bases: <code>FnWrapper</code></p> <p>(Optionally) removes fields from the input kwargs and reinserts them back into the output</p> <p>Parameters:</p> <ul> <li> *id_fields             (<code>str</code>, default:                 <code>()</code> )         \u2013          <p>fields to pop from the kwargs</p> </li> <li> keep             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>if True, <code>id_fields</code> are not removed from kwargs (but still remembered and reinserted into the output)</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/wrappers/#ralsei.map_fn.wrappers.RenameInput","title":"<code>RenameInput(remap_fields)</code>","text":"<p>             Bases: <code>FnWrapper</code></p> <p>Remaps field names in the <code>**kwargs</code> dictionary</p> <p>Parameters:</p> <ul> <li> remap_fields             (<code>dict[str, str]</code>)         \u2013          <p>old_name -&gt; new_name remap</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/wrappers/#ralsei.map_fn.wrappers.RenameOutput","title":"<code>RenameOutput(remap_fields)</code>","text":"<p>             Bases: <code>FnWrapper</code></p> <p>Remaps field values in dictionaries generated by the inner function</p> <p>Parameters:</p> <ul> <li> remap_fields             (<code>dict[str, str]</code>)         \u2013          <p>old_name -&gt; new_name remap</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/wrappers/#ralsei.map_fn.wrappers.AddToInput","title":"<code>AddToInput(add_values)</code>","text":"<p>             Bases: <code>FnWrapper</code></p> <p>Add extra key-value pairs to input</p> <p>Parameters:</p> <ul> <li> add_values             (<code>dict[str, Any]</code>)         \u2013          <p>field names and values</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/wrappers/#ralsei.map_fn.wrappers.AddToOutput","title":"<code>AddToOutput(add_values)</code>","text":"<p>             Bases: <code>FnWrapper</code></p> <p>Add extra key-value pairs to output</p> <p>Parameters:</p> <ul> <li> add_values             (<code>dict[str, Any]</code>)         \u2013          <p>field names and values</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/wrappers/#ralsei.map_fn.wrappers.into_many","title":"<code>into_many(fn)</code>","text":"<p>Convert a regular function into a generator function yielding a single value</p> <p>Parameters:</p> <ul> <li> fn             (<code>OneToOne</code>)         \u2013          <p>inner function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OneToMany</code>         \u2013          <p>wrapped function</p> </li> </ul>"},{"location":"reference/ralsei/map_fn/wrappers/#ralsei.map_fn.wrappers.into_one","title":"<code>into_one(fn)</code>","text":"<p>Convert a function that returns a generator yielding a single value into a function that returns that value</p> <p>Parameters:</p> <ul> <li> fn             (<code>OneToMany</code>)         \u2013          <p>inner function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OneToOne</code>         \u2013          <p>wrapped function</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>If there's more than one value in the generator</p> </li> </ul>"},{"location":"reference/ralsei/task/","title":"Index","text":""},{"location":"reference/ralsei/task/#ralsei.task","title":"<code>task</code>","text":"<p>Classes desscribing actions in the database</p>"},{"location":"reference/ralsei/task/add_columns_sql/","title":"add_columns_sql","text":""},{"location":"reference/ralsei/task/add_columns_sql/#ralsei.task.add_columns_sql","title":"<code>add_columns_sql</code>","text":""},{"location":"reference/ralsei/task/add_columns_sql/#ralsei.task.add_columns_sql.AddColumnsSql","title":"<code>AddColumnsSql(sql, table, columns=None, params={})</code>","text":"<p>             Bases: <code>Task</code></p> <p>Adds the specified Columns to an existing Table and runs the SQL script to fill them with data</p> <p>Parameters:</p> <ul> <li> sql             (<code>str</code>)         \u2013          <p>sql template string</p> </li> <li> table             (<code>Table</code>)         \u2013          <p>Table to add columns to</p> </li> <li> columns             (<code>Optional[list[Column]]</code>, default:                 <code>None</code> )         \u2013          <p>these column definitions take precedence over those defined in the template</p> </li> <li> params             (<code>dict</code>, default:                 <code>{}</code> )         \u2013          <p>parameters passed to the jinja template</p> </li> </ul> Template <p>Environment variables: <code>table</code>, <code>**params</code></p> <p>Columns can be defined in the template itself, using <code>{% set columns = [...] %}</code></p> Example postprocess.sql<pre><code>{% set columns = [Column(\"name_upper\", \"TEXT\")] %}\nUPDATE {{table}}\nSET name_upper = UPPER(name);\n</code></pre> pipeline.py<pre><code>\"postprocess\": AddColumnsSql(\nsql=Path(\"./postprocess.sql\").read_text(),\ntable=TABLE_people,\n)\n</code></pre>"},{"location":"reference/ralsei/task/base/","title":"base","text":""},{"location":"reference/ralsei/task/base/#ralsei.task.base","title":"<code>base</code>","text":""},{"location":"reference/ralsei/task/base/#ralsei.task.base.Task","title":"<code>Task()</code>","text":"<p>Attributes:</p> <ul> <li> scripts             (<code>dict[str, Composed]</code>)         \u2013          <p>Named SQL scripts created by the <code>render</code> method</p> </li> </ul> <p>Base Task class</p>"},{"location":"reference/ralsei/task/base/#ralsei.task.base.Task.render","title":"<code>render(renderer)</code>","text":"<p>Render your sql scripts here, like this: <pre><code>self.scripts[\"Create table\"] = self.__create_table = renderer.render(...)\n</code></pre></p> <p>This methon runs before <code>run</code> and <code>delete</code></p> <p>Parameters:</p> <ul> <li> renderer             (<code>RalseiRenderer</code>)         \u2013          <p>jinja sql renderer</p> </li> </ul>"},{"location":"reference/ralsei/task/base/#ralsei.task.base.Task.exists","title":"<code>exists(conn)</code>  <code>abstractmethod</code>","text":"<p>Check if task has already been done</p> <p>Parameters:</p> <ul> <li> conn             (<code>PsycopgConn</code>)         \u2013          <p>db connection</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>has been done?</p> </li> </ul>"},{"location":"reference/ralsei/task/base/#ralsei.task.base.Task.run","title":"<code>run(conn)</code>  <code>abstractmethod</code>","text":"<p>Execute the task</p> <p>Parameters:</p> <ul> <li> conn             (<code>PsycopgConn</code>)         \u2013          <p>db connection</p> </li> </ul>"},{"location":"reference/ralsei/task/base/#ralsei.task.base.Task.delete","title":"<code>delete(conn)</code>  <code>abstractmethod</code>","text":"<p>Delete whatever <code>run()</code> method has created</p> <p>Parameters:</p> <ul> <li> conn             (<code>PsycopgConn</code>)         \u2013          <p>db connection</p> </li> </ul>"},{"location":"reference/ralsei/task/common/","title":"common","text":""},{"location":"reference/ralsei/task/common/#ralsei.task.common","title":"<code>common</code>","text":"<p>All the common imports for writing a task</p>"},{"location":"reference/ralsei/task/common/#ralsei.task.common.merge_params","title":"<code>merge_params(*dicts)</code>","text":"<p>Merge dictionaries, asserting there are no duplicate keys</p> <p>Parameters:</p> <ul> <li> *dicts             (<code>dict</code>, default:                 <code>()</code> )         \u2013          <p>dictionaries to merge</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>merged dict</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>duplicate key</p> </li> </ul>"},{"location":"reference/ralsei/task/create_table_sql/","title":"create_table_sql","text":""},{"location":"reference/ralsei/task/create_table_sql/#ralsei.task.create_table_sql","title":"<code>create_table_sql</code>","text":""},{"location":"reference/ralsei/task/create_table_sql/#ralsei.task.create_table_sql.CreateTableSql","title":"<code>CreateTableSql(sql, table, params={}, view=False)</code>","text":"<p>             Bases: <code>Task</code></p> <p>Runs a <code>CREATE TABLE</code> sql script</p> <p>Parameters:</p> <ul> <li> sql             (<code>str</code>)         \u2013          <p>sql template string</p> </li> <li> table             (<code>Table</code>)         \u2013          <p>Table being created</p> </li> <li> params             (<code>dict</code>, default:                 <code>{}</code> )         \u2013          <p>parameters passed to the jinja template</p> </li> <li> view             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>whether this is a VIEW instead of a TABLE</p> </li> </ul> Template <p>Environment variables: <code>table</code>, <code>**params</code></p> Example unnest.sql<pre><code>CREATE TABLE {{table}}(\nid SERIAL PRIMARY KEY,\nname TEXT\n);\nINSERT INTO {{table}}(name)\nSELECT json_array_elements_text(json-&gt;'names')\nFROM {{sources}};\n</code></pre> pipeline.py<pre><code>\"unnest\": CreateTableSql(\nsql=Path(\"./unnest.sql\").read_text(),\ntable=TABLE_names,\nparams={\"table\": TABLE_sources},\n)\n</code></pre>"},{"location":"reference/ralsei/task/map_to_new_columns/","title":"map_to_new_columns","text":""},{"location":"reference/ralsei/task/map_to_new_columns/#ralsei.task.map_to_new_columns","title":"<code>map_to_new_columns</code>","text":""},{"location":"reference/ralsei/task/map_to_new_columns/#ralsei.task.map_to_new_columns.MapToNewColumns","title":"<code>MapToNewColumns(select, table, columns, fn, is_done_column=None, id_fields=None, params={}, cursor_factory=ClientCursorFactory())</code>","text":"<p>             Bases: <code>Task</code></p> <p>Applies the provided map function to a query result, saving outputs into new columns on the same row</p> <p>Parameters:</p> <ul> <li> select             (<code>str</code>)         \u2013          <p>the <code>SELECT</code> statement that generates the input rows passed to function <code>fn</code> as arguments</p> </li> <li> table             (<code>Table</code>)         \u2013          <p>Table to add columns to</p> </li> <li> columns             (<code>list[ValueColumn]</code>)         \u2013          <p>a list of <code>ValueColumn</code>s used for <code>ADD COLUMN</code> and <code>UPDATE</code> statement generation.</p> </li> <li> fn             (<code>OneToOne | FnBuilder</code>)         \u2013          <p>A function that maps one row to values of the new columns in the same row.</p> <p>If a function builder was passed instead of the function itself, the task will try to infer the table's <code>id_fields</code> from its metadata</p> </li> <li> is_done_column             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>create a boolean column with the given name in <code>table</code> that tracks which rows have been processed.</p> <p>If specified, the task will commit after each successful run of <code>fn</code>, allowing you to stop and resume from the same place.</p> <p>Make sure to include <code>WHERE NOT {{is_done}}</code> in your <code>select</code> statement</p> </li> <li> id_fields             (<code>Optional[list[IdColumn]]</code>, default:                 <code>None</code> )         \u2013          <p>columns that uniquely identify a row in <code>table</code>.</p> <p>This argument takes precedence over the <code>id_fields</code> inferred from <code>FnBuilder</code>'s metadata</p> </li> <li> params             (<code>dict</code>, default:                 <code>{}</code> )         \u2013          <p>parameters passed to the jinja template</p> </li> <li> cursor_factory             (<code>CursorFactory</code>, default:                 <code>ClientCursorFactory()</code> )         \u2013          <p>if the number of rows generated by <code>select</code> is too large to fit into memory, you can use ralsei.ServerCursorFactory</p> </li> </ul> Template <p>Environment variables:</p> <ul> <li><code>table</code>: equals to <code>table</code> argument</li> <li><code>is_done</code>: equals to <code>is_done_column</code> argument</li> </ul> Example <pre><code>from psycopg.sql import SQL\ndef download(url: str):\nresponse = requests.get(url)\nresponse.raise_for_status()\nreturn { \"html\": response.text() }\ndef parse(html: str):\nsel = Selector(html)\nreturn {\n\"title\": sel.xpath(\"//h1/text()\").get(),\n\"rating\": sel.xpath(\"//div[@id='rating']/text()\").get()\n}\ncli.run({\n\"download\": MapToNewColumns(\ntable=TABLE_pages,\nselect=\"SELECT id, url FROM {{table}} WHERE NOT {{is_done}}\", # (1)!\ncolumns=[\nValueColumn(\"html\", \"TEXT\"), # (2)!\nValueColumn(\"date_downloaded\", \"DATE\", SQL(\"NOW()\")), # (3)!\n],\nis_done_column=\"__downloaded\", # (4)!\nfn=FnBuilder(download).pop_id_fields(\"id\"), # (5)!\n),\n\"parse\": MapToNewColumns(\ntable=TABLE_pages,\nselect=\"SELECT id, html FROM {{table}}\",\ncolumns=[\nValueColumn(\"title\", \"TEXT\"),\nValueColumn(\"rating\", \"TEXT\"),\n],\nfn=FnBuilder(parse).pop_id_fields(\"id\")\n),\n})\n</code></pre> <ol> <li>Filter out pages that have already been downloaded</li> <li>This column's value will be determined by <code>download</code> function</li> <li>Overriding the value</li> <li>Add a boolean column for tracking the progress</li> <li>This serves 2 purposes:    1) Removes <code>id</code> from the arguments    of <code>download</code> and later attaches    it to its output dict    2) Allows the task to infer that <code>id</code>    uniquely identifies <code>table</code> rows.    If not true, you can override this    with ihe <code>id_fields</code> argument</li> </ol>"},{"location":"reference/ralsei/task/map_to_new_table/","title":"map_to_new_table","text":""},{"location":"reference/ralsei/task/map_to_new_table/#ralsei.task.map_to_new_table","title":"<code>map_to_new_table</code>","text":""},{"location":"reference/ralsei/task/map_to_new_table/#ralsei.task.map_to_new_table.MapToNewTable","title":"<code>MapToNewTable(table, columns, fn, select=None, source_table=None, is_done_column=None, id_fields=None, params={}, cursor_factory=ClientCursorFactory())</code>","text":"<p>             Bases: <code>Task</code></p> <p>Applies the provided map function to a query result, mapping a single row to one or more rows in a new table</p> <p>Parameters:</p> <ul> <li> table             (<code>Table</code>)         \u2013          <p>The new table being created</p> </li> <li> columns             (<code>list[str | ValueColumn]</code>)         \u2013          <p>Columns (and constraints) that make up the table definition.</p> <p>Additionally, <code>ValueColumn</code>s <code>value</code> field is used in the generation of the <code>INSERT</code> statement (if not specified, <code>value</code> will be set to a SQL Placeholder with the same name as the column).</p> <p><code>str</code> columns and <code>ValueColumn.type</code> string are passed through the jinja preprocessor.</p> </li> <li> fn             (<code>OneToMany | GeneratorBuilder</code>)         \u2013          <p>A generator function, mapping one row to many rows.</p> <p>If a function builder was passed instead of the function itself,   the task will try to infer the table's <code>id_fields</code> from its metadata</p> </li> <li> select             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>The <code>SELECT</code> statement that generates the input rows passed to function <code>fn</code> as arguments.</p> <p>If not specified, <code>fn</code> will only run once with 0 arguments.</p> </li> <li> source_table             (<code>Optional[Table]</code>, default:                 <code>None</code> )         \u2013          <p>The table that the input rows come from. Only useful if you want to create <code>is_done_column</code>.</p> </li> <li> is_done_column             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>Create a boolean column with the given name in <code>source_table</code> that tracks which rows have been processed.</p> <p>If specified, the task will commit after each successful run of <code>fn</code>, allowing you to stop and resume from the same place.</p> <p>Make sure to include <code>WHERE NOT {{is_done}}</code> in your <code>select</code> statement</p> </li> <li> id_fields             (<code>Optional[list[IdColumn]]</code>, default:                 <code>None</code> )         \u2013          <p>Columns that uniquely identify a row in <code>source_table</code>. Only useful if you want to create <code>is_done_column</code>.</p> <p>This argument takes precedence over the <code>id_fields</code> inferred from <code>GeneratorBuilder</code>'s metadata</p> </li> <li> params             (<code>dict</code>, default:                 <code>{}</code> )         \u2013          <p>parameters passed to the jinja template</p> </li> <li> cursor_factory             (<code>CursorFactory</code>, default:                 <code>ClientCursorFactory()</code> )         \u2013          <p>if the number of rows generated by <code>select</code> is too large to fit into memory, you can use ralsei.ServerCursorFactory</p> </li> </ul> Template <p>Environment variables:</p> <ul> <li><code>table</code>: equals to <code>table</code> argument</li> <li><code>source</code>: equals to <code>source_table</code> argument</li> <li><code>is_done</code>: equals to <code>is_done_column</code> argument</li> <li><code>**params</code></li> </ul> Example <pre><code># Find subjects on the hub page\ndef find_subjects(hub_url: str):\nhtml = download(hub_url)\nsel = Selector(html)\nfor row in sel.xpath(\"//table/tr\"):\nyield {\n\"subject\": row.xpath(\"a/text()\").get(),\n\"url\": row.xpath(\"a/@href\").get()\n}\n# Download all pages in a subject rating\ndef download_pages(url: str):\nnext_url = url\npage = 1\nwhile next_url is not None:\nhtml = download(next_url)\nyield { \"page\": page, \"html\": html }\nsel = Selector(html)\nnext_url = sel.xpath(\"//a[@id = 'next']\").get()\npage += 1\ncli.run({\n\"subjects\": MapToNewTable(\ntable=TABLE_subjects,\ncolumns=[ # (1)!\n\"id SERIAL PRIMARY KEY\",\nValueColumn(\"subject\", \"TEXT\"),\nValueColumn(\"url\", \"TEXT\"),\n],\nfn=GeneratorBuilder(find_subjects).add_to_input( # (2)!\n{ \"hub_url\": \"https://rating.com/2022\" }\n)\n),\n\"pages\": MapToNewTable(\nsource_table=TABLE_subjects,\nselect=\"\"\"\\\n        SELECT id, url FROM {{source}}\n        WHERE NOT {{is_done}}\"\"\", # (3)!\ncolumns=[\nValueColumn(\n\"subject_id\",\n\"INT REFERENCES {{source}}(id)\", # (4)!\nPlaceholder(\"id\")\n),\nValueColumn(\"page\", \"INT\"),\nValueColumn(\"html\", \"TEXT\"),\n\"date_downloaded DATE DEFAULT NOW()\",\n],\nis_done_column=\"__downloaded\", # (5)!\nfn=GeneratorBuilder(download_pages)\n.pop_id_fields(\"id\") # (6)!\n)\n})\n</code></pre> <ol> <li> <p>Table body is generated from all <code>columns</code>,    INSERT statement - only from <code>ValueColumn</code>s</p> </li> <li> <p>Since there is no SELECT statement,    you have to transform <code>find_subjects</code>    into a function that takes 0 arguments</p> </li> <li> <p>Filter out subjects that have already been downloaded</p> </li> <li> <p>jinja templates are allowed</p> </li> <li> <p>Column <code>__downloaded</code> will be added to <code>TABLE_subjects</code></p> </li> <li> <p>This serves 2 purposes:    1) Removes <code>id</code> from the arguments    of <code>download_pages</code> and later attaches    it to its output rows    2) Allows the task to infer that <code>id</code>    uniquely identifies <code>source_table</code> rows.    If not true, you can override this    with ihe <code>id_fields</code> argument</p> </li> </ol>"},{"location":"reference/ralsei/templates/","title":"Index","text":""},{"location":"reference/ralsei/templates/#ralsei.templates","title":"<code>templates</code>","text":"<p>SQL template building blocks</p> Example <pre><code>table: Table(\"people\")\ncolumns = [\nValueColumn(\"id\", \"INT\"),\nValueColumn(\"name\", \"TEXT\"),\n]\nrenderer.render(\n\"\"\"\\\n    CREATE TABLE {{ table }}(\n        {{ columns | sqljoin(',\\n') }}\n    );\n    INSERT INTO {{ table }}(\n        {{ columns | sqljoin(',\\n', attribute='ident') }}\n    )\n    VALUES (\n        {{ columns | sqljoin(',\\n', attribute='value') }}\n    );\"\"\",\n{ \"table\": table, \"columns\": map(\nlambda col: col.render(renderer, {}),\ncolumns\n) }\n)\n</code></pre>"},{"location":"reference/ralsei/templates/column/","title":"column","text":""},{"location":"reference/ralsei/templates/column/#ralsei.templates.column","title":"<code>column</code>","text":""},{"location":"reference/ralsei/templates/column/#ralsei.templates.column.Column","title":"<code>Column</code>  <code>dataclass</code>","text":"<p>Column definition in <code>ADD COLUMN</code> or <code>CREATE TABLE</code> statement</p> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>column name</p> </li> <li> type             (<code>str</code>)         \u2013          <p>Everything that comes after column name: data type, <code>REFERENCES</code>, <code>UNIQUE</code>, <code>DEFAULT</code>, etc.</p> <p>Can be a jinja template</p> </li> </ul>"},{"location":"reference/ralsei/templates/column/#ralsei.templates.column.Column.render","title":"<code>render(renderer, params={})</code>","text":"<p>Put through the jinja renderer</p> <p>Parameters:</p> <ul> <li> renderer             (<code>RalseiRenderer</code>)         \u2013          <p>jinja sql renderer</p> </li> <li> params             (<code>dict</code>, default:                 <code>{}</code> )         \u2013          <p>template parameters</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ColumnRendered</code>         \u2013          <p>column with the <code>type</code> field rendered</p> </li> </ul>"},{"location":"reference/ralsei/templates/column/#ralsei.templates.column.ColumnRendered","title":"<code>ColumnRendered</code>  <code>dataclass</code>","text":"<p>Column definition in <code>ADD COLUMN</code> or <code>CREATE TABLE</code> statement</p> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>column name</p> </li> <li> type             (<code>Composed</code>)         \u2013          <p>Everything that comes after column name: data type, <code>REFERENCES</code>, <code>UNIQUE</code>, <code>DEFAULT</code>, etc.</p> <p>Rendered using psycopg</p> </li> </ul>"},{"location":"reference/ralsei/templates/column/#ralsei.templates.column.ColumnRendered.ident","title":"<code>ident: Identifier</code>  <code>property</code>","text":"<p>Column name as psycopg identifier</p> <p>Returns:</p> <ul> <li> <code>Identifier</code>         \u2013          <p>wrapped column name</p> </li> </ul>"},{"location":"reference/ralsei/templates/column/#ralsei.templates.column.ColumnRendered.__sql__","title":"<code>__sql__()</code>","text":"<p>sql representation</p> <p>Returns:</p> <ul> <li> <code>Composed</code>         \u2013          <p>name + type</p> </li> </ul>"},{"location":"reference/ralsei/templates/column/#ralsei.templates.column.ColumnRendered.add","title":"<code>add(if_not_exists)</code>","text":"<p>Generate <code>ADD COLUMN statement</code></p> <p>Parameters:</p> <ul> <li> if_not_exists             (<code>bool</code>)         \u2013          <p>whether to use <code>IF NOT EXISTS</code></p> </li> </ul> <p>Returns:     <code>ADD COLUMN</code></p>"},{"location":"reference/ralsei/templates/column/#ralsei.templates.column.ColumnRendered.drop","title":"<code>drop(if_exists)</code>","text":"<p>Generate <code>DROP COLUMN statement</code></p> <p>Parameters:</p> <ul> <li> if_exists             (<code>bool</code>)         \u2013          <p>whether to use <code>IF EXISTS</code></p> </li> </ul> <p>Returns:     <code>DROP COLUMN</code></p>"},{"location":"reference/ralsei/templates/table/","title":"table","text":""},{"location":"reference/ralsei/templates/table/#ralsei.templates.table","title":"<code>table</code>","text":""},{"location":"reference/ralsei/templates/table/#ralsei.templates.table.Table","title":"<code>Table</code>  <code>dataclass</code>","text":"<p>Table identifier in a database</p> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>table name</p> </li> <li> schema             (<code>Optional[str]</code>)         \u2013          <p>table schema</p> </li> </ul>"},{"location":"reference/ralsei/templates/table/#ralsei.templates.table.Table.__sql__","title":"<code>__sql__()</code>","text":"<p>sql representation</p> <p>Returns:</p> <ul> <li> <code>Composable</code>         \u2013          <p>schema.name</p> </li> </ul>"},{"location":"reference/ralsei/templates/value_column/","title":"value_column","text":""},{"location":"reference/ralsei/templates/value_column/#ralsei.templates.value_column","title":"<code>value_column</code>","text":""},{"location":"reference/ralsei/templates/value_column/#ralsei.templates.value_column.ValueColumn","title":"<code>ValueColumn(name, type, value=_FROM_NAME)</code>","text":"<p>             Bases: <code>Column</code></p> <p>Defines a column that should be filled with some value</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>column name</p> </li> <li> type             (<code>str</code>)         \u2013          <p>Everything that comes after column name: data type, <code>REFERENCES</code>, <code>UNIQUE</code>, <code>DEFAULT</code>, etc.</p> <p>Can be a jinja template</p> </li> <li> value             (<code>Any</code>, default:                 <code>_FROM_NAME</code> )         \u2013          <p>value that will be baked into the <code>INSERT</code> statement. Can be a SQL placeholder or a constant</p> <p>By default, equals to a SQL placeholder     with the same name as the column</p> </li> </ul>"},{"location":"reference/ralsei/templates/value_column/#ralsei.templates.value_column.ValueColumn.render","title":"<code>render(renderer, params={})</code>","text":"<p>Put through the jinja renderer</p> <p>Parameters:</p> <ul> <li> renderer             (<code>RalseiRenderer</code>)         \u2013          <p>jinja sql renderer</p> </li> <li> params             (<code>dict</code>, default:                 <code>{}</code> )         \u2013          <p>template parameters</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ValueColumnRendered</code>         \u2013          <p>column with the <code>type</code> field rendered</p> </li> </ul>"},{"location":"reference/ralsei/templates/value_column/#ralsei.templates.value_column.ValueColumnRendered","title":"<code>ValueColumnRendered(column, value)</code>","text":"<p>             Bases: <code>ColumnRendered</code></p> <p>Defines a column that should be filled with some value</p> <p>Parameters:</p> <ul> <li> column             (<code>ColumnRendered</code>)         \u2013          <p>column name and type</p> </li> <li> value             (<code>Any</code>)         \u2013          <p>value that will be baked into the <code>INSERT</code> statement. Can be a SQL placeholder or a constant</p> </li> </ul>"},{"location":"reference/ralsei/templates/value_column/#ralsei.templates.value_column.ValueColumnRendered.definition","title":"<code>definition: Composed</code>  <code>property</code>","text":"<p>Returns:</p> <ul> <li> <code>Composed</code>         \u2013          <p>column definition (name + type)</p> </li> </ul>"},{"location":"reference/ralsei/templates/value_column/#ralsei.templates.value_column.ValueColumnRendered.set","title":"<code>set: Composed</code>  <code>property</code>","text":"<p><code>SET</code> statement contents</p> <p>Returns:</p> <ul> <li> <code>Composed</code>         \u2013          <p>name = value</p> </li> </ul>"},{"location":"reference/ralsei/templates/value_column/#ralsei.templates.value_column.IdColumn","title":"<code>IdColumn(name, value=_FROM_NAME)</code>","text":"<p>Defines a column value that uniquely identifies a particular row</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>column name</p> </li> <li> value             (<code>Any</code>, default:                 <code>_FROM_NAME</code> )         \u2013          <p>value that will be baked into a <code>WHERE</code> statement. Can be a SQL placeholder or a constant</p> <p>By default, equals to a SQL placeholder with the same name as the column</p> </li> </ul>"},{"location":"reference/ralsei/templates/value_column/#ralsei.templates.value_column.IdColumn.__sql__","title":"<code>__sql__()</code>","text":"<p>sql representation</p> <p>Returns:</p> <ul> <li> <code>Composed</code>         \u2013          <p>name = value</p> </li> </ul>"}]}